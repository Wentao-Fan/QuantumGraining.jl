var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-BVector","page":"API","title":"BVector","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DVec\nUVec\nBVector","category":"page"},{"location":"api/#QuantumGraining.DVec","page":"API","title":"QuantumGraining.DVec","text":"\"     DVec(u::Vector; special=false) Creates a BVector with type :down. Assumes the frequency ordering is clockwise\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.UVec","page":"API","title":"QuantumGraining.UVec","text":"\"     UVec(u::Vector; special=false) Creates a BVector with type :up. Assumes the frequency ordering is clockwise\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.BVector","page":"API","title":"QuantumGraining.BVector","text":"BVector{T} <: AbstractVector{T}\n\nA struct representing the up- or down-modes. The poles are stored in the poles field.\n\nArguments:     - freqs: A vector representing the frequencies of the vector.     - poles: A vector of the indices of poles of the vector, if any. Does not include the special mode, if there is one.     - special: A boolean representing whether the vector is the special mode.     - type: A symbol representing the type of the vector. Must be :up or :down.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Diagrams","page":"API","title":"Diagrams","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DiagramNode\nnode_decomp\nget_diagrams\nDiagram","category":"page"},{"location":"api/#QuantumGraining.DiagramNode","page":"API","title":"QuantumGraining.DiagramNode","text":"DiagramNode\n\nThe DiagramNode struct is a type for one bubble in the diagram.  It is defined as a recursive tree where the elements represent the different decompositions of one node into two. \n\nFields:\n\nroot::Tuple{Int, Int}: The root of the tree, the largest common bubble defining the contraction.\nval::Tuple{Int, Int}: The value of the current node, determines how much of the bubble was broken to the left.\nrightmost::Tuple{Int, Int}: The value of the rightmost bubble.\nright::DiagramNode: Pointer to the next right node of the tree, a diagram with one mode broken to the down-bubble.\nleft::DiagramNode: Pointer to the next left node of the tree, a diagram with one mode broken to the up-bubble.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumGraining.get_diagrams","page":"API","title":"QuantumGraining.get_diagrams","text":"get_diagrams(init_diagram::Array)\n\nUses the above node_decomp() to get all possible diagrams recursively.\n\nArguments\n\nnode::AbstractDiagramNode: The initial diagram including the first level of breakdowns (two bubble diagrams)\n\nReturns\n\nA list of all possible diagrams for a given contractions.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.Diagram","page":"API","title":"QuantumGraining.Diagram","text":"Diagram{T1, T2} <: AbstractVector{Tuple{T1, T2}}\n\nA struct representing a diagram, also takes care of the edge mode.\n\nArguments:     - bubbles: A vector of bubbles.     - freqs: A vector of tuples of BVectors. The first element of the tuple is the up-bubble, the second is the down-bubble.     - shape: A vector of tuples representing the shape of the bubbles.     - uppoles: A vector of vectors representing the up-poles of the bubbles.     - downpoles: A vector of vectors representing the down-poles of the bubbles.     - num_poles: An integer representing the number of poles in the diagram.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Poles","page":"API","title":"Poles","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Contraction\ncount_poles\nfind_poles\nfind_all_poles\nfind_integer_solutions\nreshape_sols","category":"page"},{"location":"api/#QuantumGraining.count_poles","page":"API","title":"QuantumGraining.count_poles","text":"count_poles(s_list::Vector{Int}, stag_list::Vector{Int})\n\nGiven two lists of poles, counts the total number of poles by counting the non-empty lists.\n\nArgument:      - slist: list of upper poles     - staglist: list of lower poles\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.find_poles","page":"API","title":"QuantumGraining.find_poles","text":"find_poles(u)\n\nFinds all the factors of the vector factorial that evaluate to 0.\n\nArgument:      - ω = [(μ1, ν1), ..., (μ||d||, ν||d||)]\n\nReturns:     - poles_list: list of indices of poles\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.find_all_poles","page":"API","title":"QuantumGraining.find_all_poles","text":"find_all_poles(d::Vector{Tuple{BVector{T1}, BVector{T2}}}) where {T1, T2}\n\nFind all poles in the given vector of tuples d. Each tuple contains two BVector objects, μ and ν. The function iterates over each tuple and performs the following steps:\n\nIf μ.special is true, it removes the first element from μ.\nReverses the order of elements in μ.\nCalls the find_poles function to find the poles in μ and ν.\nAppends the resulting poles to up_poles and down_poles respectively.\n\nArguments\n\nd::Vector{Tuple{BVector{T1}, BVector{T2}}}: A vector of tuples, where each tuple contains two BVector objects.\n\nReturns\n\nA tuple (up_poles, down_poles) where up_poles is a vector of vectors containing the poles found in μ, and down_poles is a vector of vectors containing the poles found in ν.\n\n\n\n\n\nfind_all_poles(d::Vector{Tuple{Vector{T1}, Vector{T2}}}) where {T1, T2}\n\nFinds all poles in vector factorial for frequency list d. Assumes that the first tuple in the list is the special mode.\n\nArgument:      - ω = [(μ1, ν1), ..., (μ||d||, ν||d||)] Returns:     - uppoles: list of indices of poles in upper modes     - downpoles: list of indices of poles in lower modes\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.find_integer_solutions","page":"API","title":"QuantumGraining.find_integer_solutions","text":"find_integer_solutions(num_vars::Int, target_sum::Int, combination::Vector{Int}=Vector{Int}(), sum_so_far::Int=0)\n\nFunction that calculates combinations of k positive integers adding up to m, as detailed in the paper.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.reshape_sols","page":"API","title":"QuantumGraining.reshape_sols","text":"reshapesols(sols, targetsum, numbubbles, numindices = 3)\n\nHelper function that reshapes integer combinations from findintegersolutions() into vectors\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Contractions","page":"API","title":"Contractions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"diagram_correction\ncontraction_coeff\ncalc_pole_corrections\nCorrection\nContractionCoefficient\nsplit_freqs_into_bubbles\nto_qc_symbol","category":"page"},{"location":"api/#QuantumGraining.Correction","page":"API","title":"QuantumGraining.Correction","text":"struct Correction\n\nA struct representing a correction term.\n\nFields\n\nprefac: The prefactor of the correction term.\nexponent: The exponent of the correction term.\npoly: A vector of coefficients for the polynomial term.\norder: The order of the polynomial term.\n\nConstructors\n\nCorrection(prefac, exponent, poly=Num[1,], order=length(poly)): Constructs a Correction object with the given parameters. If poly is not provided, it defaults to [1]. If order is not provided, it defaults to the length of poly.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumGraining.ContractionCoefficient","page":"API","title":"QuantumGraining.ContractionCoefficient","text":"struct ContractionCoefficient\n\nA struct representing a contraction coefficient.\n\nFields\n\ncorrections::Vector{Correction}: Vector of Correction objects.\nexponents::Vector{Number}: Vector of exponents.\nprefacs::Vector{Number}: Vector of prefactors.\npolys::Vector{Vector{Number}}: Vector of polynomials.\n\nConstructors\n\nContractionCoefficient(exponents, prefacs, polys): Constructs a ContractionCoefficient object with given exponents, prefactors, and polynomials.\nContractionCoefficient(exponents, prefacs): Constructs a ContractionCoefficient object with given exponents and prefactors. Polynomials are set to [1] by default.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumGraining.split_freqs_into_bubbles","page":"API","title":"QuantumGraining.split_freqs_into_bubbles","text":"split_freqs_into_bubbles(freqs, diagram)\n\nSplits an array of frequencies into an array of tuples of frequencies, matching the dimensions of each bubble in diagram.\n\nArgument:     freqs - an array of frequencies in the form ω = [μ1..., μ2..., ..., μl..., ν1..., ν2..., ..., νr]     diagram - dimensions of each bubble, where each tuple is the dimension for the corresponding bubble. Returns:     ω - an array of frequencies in the form [(μ1, ν1), (μ2, ν2), ..., (μl, νl), ([], ν(l+1)), ..., ([], νr)]\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Corrections","page":"API","title":"Corrections","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"merge_duplicate_exponents\nsimplify_contraction","category":"page"},{"location":"api/#QuantumGraining.merge_duplicate_exponents","page":"API","title":"QuantumGraining.merge_duplicate_exponents","text":"merge_duplicate_exponents(c::ContractionCoefficient)\n\nMerge duplicate exponents in a ContractionCoefficient object.\n\nArguments\n\nc::ContractionCoefficient: The ContractionCoefficient object to merge duplicate exponents.\n\nReturns\n\nA new ContractionCoefficient object with merged duplicate exponents.\n\nDescription\n\nThis function takes a ContractionCoefficient object and merges any duplicate exponents. It iterates over the exponents, prefactors, and polynomials in the ContractionCoefficient object and checks for duplicates.  If duplicates are found, the prefactors and polynomials are merged into a single polynomial.  The resulting unique exponents, merged prefactors, and merged polynomials are then used to create a new ContractionCoefficient object.\n\nNote that the function uses the ordered_sum function to merge the polynomials and the simplify function to simplify the resulting polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.simplify_contraction","page":"API","title":"QuantumGraining.simplify_contraction","text":"simplify_contraction(c::ContractionCoefficient)\n\nSimplifies the given ContractionCoefficient by applying simplification operations to its components.\n\nArguments\n\nc::ContractionCoefficient: The ContractionCoefficient to be simplified.\n\nReturns\n\nA new ContractionCoefficient object with simplified components.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Bubble","page":"API","title":"Bubble","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Bubble\ncalculate_bubble_factor","category":"page"},{"location":"api/#QuantumGraining.Bubble","page":"API","title":"QuantumGraining.Bubble","text":"Bubble{T1, T2} <: AbstractVector{Tuple{T1, T2}}\n\nA struct representing a bubble, also takes care of the edge case.\n\nArguments:     - up: A BVector representing the up-bubble.     - down: A BVector representing the down-bubble.     - shape: A tuple representing the shape of the bubble.     - special: A boolean representing whether the bubble is a special edge mode bubble.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumGraining.calculate_bubble_factor","page":"API","title":"QuantumGraining.calculate_bubble_factor","text":"calculate_bubble_factor(ω, bubble_idx, total_num_poles, s, stag)\n\nReturns the bubble factor for a single bubble.\n\nArguments\n\n- `ω`: the frequency values for the whole diagram.\n- `total_num_poles`: the total number of singular poles in the diagram\n- `bubble_idx`: the index of the bubble for which we want to calculate the correction factor.\n- `s`: a list of the singular poles in the upper modes of the bubble.\n- `stag`: a list of the singular poles in the lower modes of the bubble.\n\nReturns\n\n- an array of all bubble factors.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Lindblad","page":"API","title":"Lindblad","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"effective_hamiltonian_term\neffective_dissipator_term\nrepeated_combinations\ngaussian_to_cutoff\ndrop_high_freqs\neffective_hamiltonian\neffective_dissipator","category":"page"},{"location":"api/#QuantumGraining.effective_hamiltonian_term","page":"API","title":"QuantumGraining.effective_hamiltonian_term","text":"effective_hamiltonian(h::Vector, g::Vector{Number}, Ω::Vector{Number}, k::Int)\n\nGiven a truncation order k, a list of frequencies Ω, couplings g, and operators h representing the raw Hamiltonian,  this function returns new frequencies, coupling strengths, and operators representing the Hamiltonian to order k.\n\nArguments\n\nh::Vector: A vector of operators representing the raw Hamiltonian.\ng::Vector{Number}: A vector of coupling strengths.\nΩ::Vector{Number}: A vector of frequencies.\nk::Int: The truncation order.\n\nReturns\n\nops_eff::Vector: A vector of operators representing the effective Hamiltonian to order k.\nmerged_gs::Vector: A vector of merged coupling strengths.\nωs_eff::Vector: A vector of frequencies representing the effective Hamiltonian to order k.\n\nDetails\n\nThe function calculates the effective Hamiltonian by considering all possible combinations of operators, frequencies, and coupling strengths up to order k.  It simplifies the expressions and merges duplicate coupling strengths.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.effective_dissipator_term","page":"API","title":"QuantumGraining.effective_dissipator_term","text":"effective_dissipator_term(h::Vector, gs::Vector, Ω::Vector, k::Int)\n\nCompute the effective dissipator term for a given set of parameters.\n\nArguments\n\nh::Vector: Vector of coefficients for the Hamiltonian terms.\ngs::Vector: Vector of coefficients for the jump operators.\nΩ::Vector: Vector of coefficients for the frequencies.\nk::Int: Number of terms in the Hamiltonian.\n\nReturns\n\nJ_list::Vector: Vector of tuples representing the jump operators.\nγ_list::Vector: Vector of complex numbers representing the dissipation coefficients.\nω_list::Vector: Vector of sums of frequencies.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.repeated_combinations","page":"API","title":"QuantumGraining.repeated_combinations","text":"repeated_combinations(arr::Array, n::Int)\n\nGiven a collection of terms and a number n, returns all possible n repetitions of the elements in the collection.\n\n\n\n\n\nrepeated_combinations(h::Vector, g::Vector, Ω::Vector, n::Int)\n\nGenerate all possible combinations of elements from the input vectors h, g, and Ω with repetition, forming combinations of length n.\n\nArguments\n\nh::Vector: Vector of elements for combination from h\ng::Vector: Vector of elements for combination from g\nΩ::Vector: Vector of elements for combination from Ω\nn::Int: Length of combinations to generate\n\nReturns\n\nperm_h::Vector: Vector of combinations of elements from h\nperm_g::Vector: Vector of combinations of elements from g\nperm_Ω::Vector: Vector of combinations of elements from Ω\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.gaussian_to_cutoff","page":"API","title":"QuantumGraining.gaussian_to_cutoff","text":"gaussian_to_cutoff(gs, freq_vals; cutoff=0.1, keep_small_exponents=true)\n\nApply a cutoff to Gaussian exponents based on their absolute value.\n\nArguments\n\ngs: A list of ContractionCoefficient objects representing Gaussian functions.\nfreq_vals: A dictionary mapping frequency keys to their corresponding values.\ncutoff: The cutoff value for the absolute value of the Gaussian exponents. Default is 0.1.\nkeep_small_exponents: A boolean indicating whether to keep small exponents or set them to zero. Default is true.\n\nReturns\n\nA list of ContractionCoefficient objects with the cutoff applied to the Gaussian exponents.\n\n\n\n\n\ngaussian_to_cutoff(gs::Dict, ωs::Dict, freq_vals; cutoff=0.1, keep_small_exponents=true)\n\nApply a cutoff to Gaussian exponents based on their absolute value.\n\nArguments\n\ngs: A dictionary mapping frequency keys to ContractionCoefficient objects representing Gaussian functions.\nωs: A dictionary mapping frequency keys to their corresponding values.\nfreq_vals: A dictionary mapping frequency keys to their corresponding values.\ncutoff: The cutoff value for the absolute value of the Gaussian exponents. Default is 0.1.\nkeep_small_exponents: A boolean indicating whether to keep small exponents or set them to zero. Default is true.\n\nReturns\n\nA dictionary mapping frequency keys to ContractionCoefficient objects with the cutoff applied to the Gaussian exponents.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.drop_high_freqs","page":"API","title":"QuantumGraining.drop_high_freqs","text":"drop_high_freqs(freqs_list::Vector, freqs_subs, cutoff=0.1)\n\nGiven a list of frequencies and a list of substitutions, returns only the low frequencies.\n\nArguments\n\nfreqs_list::Vector: A list of frequencies.\nfreqs_subs: A list of substitutions.\ncutoff=0.1: The cutoff value for determining low frequencies.\n\nReturns\n\nrwa: A list of indices corresponding to the low frequencies.\nfreqs_low: A list of low frequencies.\n\n\n\n\n\ndrop_high_freqs(gs_dict, freqs_dict, freqs_vals; cutoff=0.1)\n\nGiven dictionaries holding the frequencies and couplings, drops all high-frequency contributions.\n\nArguments\n\ngs_dict: A dictionary holding the coupling strengths.\nfreqs_dict: A dictionary holding the frequencies.\nfreqs_vals: A dictionary of substitutions for the frequencies.\ncutoff=0.1: The cutoff value for determining high frequencies.\n\nReturns\n\ngs_dict: The updated dictionary of coupling strengths after dropping high-frequency contributions.\nfreqs_dict: The updated dictionary of frequencies after dropping high-frequency contributions.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.effective_hamiltonian","page":"API","title":"QuantumGraining.effective_hamiltonian","text":"effective_hamiltonian(h::Vector, gs::Vector, Ω::Vector, k::Int; as_dict=false, remove_constants=true)\n\nCompute the effective Hamiltonian for a given system.\n\nArguments\n\nh::Vector: A vector of Hamiltonian terms.\ngs::Vector: A vector of coupling strengths.\nΩ::Vector: A vector of frequencies.\nk::Int: The number of terms to consider.\n\nKeyword Arguments\n\nas_dict::Bool=false: If true, the output will be returned as a dictionary of operators and frequencies.\nremove_constants::Bool=true: If true, remove constant terms from the output.\n\nReturns\n\nIf as_dict is true, returns a tuple (gs_eff, ωs_eff) where gs_eff is a dictionary of operators and ωs_eff is a dictionary of frequencies.\nIf as_dict is false, returns a tuple (unique_hs, unique_gs, ωs_eff) where unique_hs is a vector of unique operators, unique_gs is a vector of unique coupling strengths, and ωs_eff is a vector of frequencies.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.effective_dissipator","page":"API","title":"QuantumGraining.effective_dissipator","text":"effective_dissipator(h::Vector, gs::Vector, Ω::Vector, k::Int; as_dict=true)\n\nCompute the effective dissipator for a given set of parameters.\n\nArguments\n\nh::Vector: A vector of operators representing the raw Hamiltonian.\ngs::Vector: A vector of coupling strengths.\nΩ::Vector: A vector of frequencies.\nk::Int: The truncation order.\nas_dict::Bool: (optional) If true, returns the dissipator as a dictionary of operators and their corresponding dissipator terms. If false, returns the dissipator as separate vectors for operators, dissipator terms, and frequencies. Default is true.\n\nReturns\n\nIf as_dict is true, returns a tuple (γs_dict, ωs_dict) where γs_dict is a dictionary of operators and their corresponding dissipator terms, and ωs_dict is a dictionary of operators and their corresponding frequencies.\nIf as_dict is false, returns a tuple (ops_eff, γs_eff, ωs_eff) where ops_eff is a vector of operators representing the effective dissipator, γs_eff is a vector of dissipator terms, and ωs_eff is a vector of frequencies.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Printing","page":"API","title":"Printing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"symbolic_hamiltonian\nto_symbol","category":"page"},{"location":"api/#QuantumGraining.symbolic_hamiltonian","page":"API","title":"QuantumGraining.symbolic_hamiltonian","text":"symbolic_hamiltonian(gs::Vector, ops::Vector, Ω::Vector, t, τ)\n\nConstructs a symbolic Hamiltonian for a quantum system.\n\nArguments\n\ngs::Vector: Vector of symbols representing the coefficients of the Hamiltonian terms.\nops::Vector: Vector of operators corresponding to each Hamiltonian term.\nΩ::Vector: Vector of frequencies for each Hamiltonian term.\nt: Time parameter.\nτ: Symbolic time parameter.\n\nReturns\n\nterms: Vector of symbolic Hamiltonian terms.\n\n\n\n\n\nsymbolic_hamiltonian(gs::Dict, Ω::Dict, t, τ)\n\nConstructs a symbolic Hamiltonian for a quantum system.\n\nArguments\n\ngs::Dict: A dictionary mapping operators to their corresponding coefficients.\nΩ::Dict: A dictionary mapping operators to their corresponding frequencies.\nt: The time parameter.\nτ: The time step parameter.\n\nReturns\n\nA symbolic Hamiltonian for the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.to_symbol","page":"API","title":"QuantumGraining.to_symbol","text":"to_symbol(coeff::ContractionCoefficient, τ)\n\nGive a symbolic representation of a ContractionCoefficient object.\n\nArguments\n\ncoeff::ContractionCoefficient: The ContractionCoefficient object to compute the symbol for.\nτ: The value of τ.\n\nReturns\n\nSymbolic representation of the ContractionCoefficient object.\n\n\n\n\n\nto_symbol(c::Correction, τ)\n\nGive a symbolic representation of a Correction object.\n\nArguments\n\nc::Correction: The Correction object to compute the symbol for.\nτ: The value of τ.\n\nReturns\n\nSymbolic representation of the Correction object.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Convert","page":"API","title":"Convert","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"convert_expressions\nhamiltonian_function\nnormal_ordered_dictionary\nqc_convert\nqnumber_to_qop\ncontraction_to_function\nlindblad_function","category":"page"},{"location":"api/#QuantumGraining.hamiltonian_function","page":"API","title":"QuantumGraining.hamiltonian_function","text":"hamiltonian_function(gs, ωs, h_src, h_tgt, ps; return_contraction_functions=false)\n\nConstructs a Hamiltonian function based on the given parameters for QuantumOptics.jl.\n\nArguments\n\ngs: A dictionary of contraction functions, where the keys are quantum numbers and the values are the corresponding contraction functions.\nωs: A dictionary of frequencies, where the keys are quantum numbers and the values are the corresponding frequencies.\nh_src: An array of source Hamiltonian operators.\nh_tgt: An array of target Hamiltonian operators.\nps: A dictionary of parameters, where the keys are parameter names and the values are the corresponding parameter values.\nreturn_contraction_functions: (optional) A boolean indicating whether to return the contraction functions along with the Hamiltonian function. Default is false.\n\nReturns\n\nIf return_contraction_functions is false, returns a Hamiltonian function H_func that takes a time t and a state ψ as input and returns the Hamiltonian operator applied to the state.\nIf return_contraction_functions is true, returns a tuple (H_func, func_gs) where H_func is the Hamiltonian function and func_gs is a dictionary of contraction functions, where the keys are quantum numbers and the values are the corresponding contraction functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.qnumber_to_qop","page":"API","title":"QuantumGraining.qnumber_to_qop","text":"qnumber_to_qop(qn::QuantumCumulants.QMul, op_subs, Id; mul = tensor)\n\nConverts a QuantumCumulants.QMul object to a quantum operator.\n\nArguments\n\nqn::QuantumCumulants.QMul: The QMul object representing the quantum number.\nop_subs: The operator substitutions to be applied.\nId: The identity operator.\nmul: The function used for tensor multiplication. Default is tensor.\n\nReturns\n\nThe quantum operator obtained from the QMul object.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.contraction_to_function","page":"API","title":"QuantumGraining.contraction_to_function","text":"contraction_to_function(g, ω, ps)\n\nConverts a contraction expression g into a Julia function that depends on the variables t and τ.\n\nArguments\n\ng: The contraction expression to be converted.\nω: The angular frequency.\nps: Additional parameters.\n\nReturns\n\nA Julia function that represents the contraction expression g as a function of t and τ.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.lindblad_function","page":"API","title":"QuantumGraining.lindblad_function","text":"lindblad_function(gs, Ωs, γs, ωs, h_src, h_tgt, ps)\n\nConstructs a Lindblad function that represents the Lindblad master equation for a quantum system.\n\nArguments\n\ngs: An array of complex numbers representing the coupling strengths between the system and the environment.\nΩs: An array of complex numbers representing the Rabi frequencies of the system.\nγs: An array of tuples representing the jump operators and their corresponding decay rates.\nωs: A dictionary mapping jump operators to their corresponding frequencies.\nh_src: An array of quantum operators representing the source Hamiltonian.\nh_tgt: An array of quantum operators representing the target Hamiltonian.\nps: A dictionary mapping jump operators to their corresponding probabilities.\n\nReturns\n\nA function L_func that represents the Lindblad master equation for the given quantum system for QuantumOptics.jl.\n\nThe Lindblad master equation is given by:     dρ/dt = -i[H(t, ρ), ρ] + ∑(J * ρ * J† - 0.5 * (J† * J * ρ + ρ * J† * J)) where H(t, ρ) is the time-dependent Hamiltonian, ρ is the density matrix, J is the jump operator, and J† is the adjoint of the jump operator.\n\nThe function L_func takes two arguments: t (time) and ρ (density matrix), and returns a tuple (H, J, J†, rates). H is the time-dependent Hamiltonian, J is an array of jump operators, J† is an array of adjoints of the jump operators, and rates is an array of decay rates.\n\nThe Lindblad function can be used to simulate the time evolution of a quantum system under the influence of the environment.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Ordering","page":"API","title":"Ordering","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"expand_operators\nexpand_operator\ngroup_operators","category":"page"},{"location":"api/#QuantumGraining.expand_operators","page":"API","title":"QuantumGraining.expand_operators","text":"expand_operators(hs)\n\nExpand a list of operators by applying the expand_operator function to each operator.\n\nArguments\n\nhs: A list of operators to be expanded.\n\nReturns\n\nA list of expanded operators.\n\n\n\n\n\nexpand_operators(hs, gs, ωs)\n\nGoes over any sum of operators and breaks it into the constituent operators while preserving the order of the other vectors.\n\nArguments\n\nhs: Array of operators to be expanded.\ngs: Array of coefficients corresponding to the operators.\nωs: Array of weights corresponding to the operators.\n\nReturns\n\nunique_hs: Array of expanded operators.\nunique_gs: Array of coefficients corresponding to the expanded operators.\nunique_ωs: Array of weights corresponding to the expanded operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.expand_operator","page":"API","title":"QuantumGraining.expand_operator","text":"expand_operator(h)\n\nExpand a quantum operator into a list of individual operators and their corresponding coefficients.\n\nArguments\n\nh: The quantum operator to be expanded.\n\nReturns\n\nops: A list of individual operators.\nfacs: A list of corresponding coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumGraining.group_operators","page":"API","title":"QuantumGraining.group_operators","text":"group_operators(hs, gs, ωs; as_dict=true)\n\nGroup operators based on their values and return the grouped operators.\n\nArguments\n\nhs: An array of operators.\ngs: An array of coefficients corresponding to the operators.\nωs: An array of corresponding elements.\nas_dict: A boolean indicating whether to return the grouped operators as dictionaries. Default is true.\n\nReturns\n\nIf as_dict is true, returns two dictionaries gs_dict and ωs_dict where the keys are the operators and the values are the grouped coefficients and elements respectively.\nIf as_dict is false, returns three arrays new_hs, new_gs, and new_ωs where new_hs contains the grouped operators, new_gs contains the grouped coefficients, and new_ωs contains the grouped elements.\n\n\n\n\n\ngroup_operators(hs)\n\nGroup operators in the given array hs by removing duplicates.\n\nArguments\n\nhs: An array of operators.\n\nReturns\n\nnew_hs: An array of operators with duplicates removed.\n\n\n\n\n\n","category":"function"},{"location":"theory/#A-brief-example-The-Rabi-model","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"","category":"section"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"To demonstrate the use of the method, we start with a simple but illustrative example – the Rabi model. The Rabi model describes the interaction between a single linear cavity mode and a two-level (spin) system. However, unlike the Jaynes-Cummings model, it does not assume the rotating-wave approximation (RWA) and retains the counter-rotating terms. In the strong-coupling regime, the Rabi model is of special interest since the RWA breaks down as the spin-cavity coupling strength becomes comparable or greater than the mode frequencies\\cite{BraumüllerUSCRabi,CasanovaDSCJC,AshhabUSCRabi}. In order to showcase the time-coarse graining method, we focus on this strong-coupling regime in order to investigate the effects of the counter-rotating terms on the system dynamics when all measurements have limited time resolution.","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"More concretely, the model we consider here is described by the following Hamiltonian terms in the interaction picture, $ \\begin{align} \\label{eq:Rabi Hamiltonian}     \\hat{H} &= \\frac{g}{2} \\left ( \\hat{a}^\\dagger \\hat{\\sigma}+ e^{-i(\\omegac + \\omegaa) t} + \\hat{a}\\hat{\\sigma}-e^{+i(\\omegac + \\omegaa) t} \\right ) \\\n    &+ \\frac{g}{2} \\left ( \\hat{a}^\\dagger \\hat{\\sigma-} e^{-i(\\omegac - \\omegaa) t} + \\hat{a}\\hat{\\sigma}+e^{i(\\omegac - \\omegaa) t} \\right ) \\end{align} $ where we omega_c  (omega_a)  is the cavity (atom) resonance.","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"In particular, we consider the situation where the coupling strength g is not much smaller than the spin and cavity frequencies omega_a and omega_c. i.e. g approx omega_c  (omega_a). In that regime, the counter-rotating terms assume significance, and the induced dynamics that depend on the time resolution of the measurement apparatus.","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"When observing the dynamics of a coherent-state cavity mode interacting with a single atom, the Jaynes-Cummings model (which is simply the Rabi model with the RWA employed), show collapse-revival dynamics. Due to the photon-number dispersion of a coherent state, the Rabi oscillation decoheres and revives. Interestingly, these collapse-revivla cycles are completely absent in the full Rabi-model, and as we will see, only appear under finite-time resolution (or equivalently, time-coarse graining).","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"For example, the numerical simulations in this subsection assume the following set of parameters: $ \\begin{equation}     \\begin{split}         \\frac{\\omega{c}}{2\\pi}         =         \\frac{\\omega{a}}{2\\pi}         =         2 \\textrm{GHz};         \\qquad         \\frac{g}{4\\pi} = 0.4 \\textrm{GHz}.     \\end{split} \\end{equation} $ Under this set of parameters, the spin-state population shows rapid oscillation whose amplitude undergoes intricate evolution over a much longer time scale, as shown in Fig.\\ref{fig:rabi-models}. However, the infinite-resolution dynamics cannot be observed in most experiments. When measurements on the system are performed with ns-level time resolution as is typical in heterodyne-based monitoring of the system, the collapse-revival pattern in the dynamics of the spin population can be recovered by taking a moving average of it.","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"With the TCG method, we obtain an effective description that gives us \\textbf{directly} the time-averaged observables that would be obtained from a bandwidth-limited measurement apparatus.  The TCG description produces a set of operators, comprised of products of the original Hamiltonian operators (i.e. multi-body transitions) h^(k)_vecmu, and their corresponding coupling strengths g_vecmu^(k). In general, the produced TCG evolution does not need to be unitary, and produces also a set of pairs of pseudo-dissipators (hatL_vecmu hatJ_vecnu) with complex coupling rate igamma_vecmu vecnu^(k). These coupling strengths are encoded in a set of frequency-dependent scalars we call \"contraction coefficients\" C_lr(vecmu vecnu). $     \\begin{subequations}         \\begin{align}         g^{(k)}{\\vec\\mu}         &         =         \\sum{\\vec{\\mu} \\in \\mathcal{P}{k,0}[\\Omega]} \\frac{1}{2} \\big( C{k,0}(\\vec{\\mu}) + C{k,0}(-\\vec{\\mu}^{\\,\\textrm{rev}}) \\big) \\\n        h^{(k)}{\\vec{\\mu}}         &         =         \\prod{\\vec{\\mu} \\in \\mathcal{P}{k,0}[\\Omega]} \\hat{h}{\\mu{k}} \\hat{h}{\\mu{k-1}} \\cdots \\hat{h}{\\mu{1}} \\\n        i \\gamma^{(k)}{\\vec{\\mu}, \\vec{\\nu}}     &=     \\sum{(\\vec{\\mu}, \\vec{\\nu}) \\in \\mathcal{P}{l,r}[\\Omega]} C{l,r}(\\vec{\\mu}, \\vec{\\nu}) - C{r,l}(-\\vec{\\nu}^{\\,\\textrm{rev}}, -\\vec{\\mu}^{\\,\\textrm{rev}}) \\\n    \\big( \\hat{L}{\\vec{\\mu}}, \\hat{J}{\\vec{\\nu}} \\big)     &     =     \\Big{ \\big( \\hat{h}{\\mu{l}} \\hat{h}{\\mu{l-1}} \\cdots \\hat{h}{\\mu{1}}, \\hat{h}{\\nu{1}} \\hat{h}{\\nu{2}} \\cdots \\hat{h}{\\nu{r}} \\big) \\quad \\vert \\quad (\\vec{\\mu}, \\vec{\\nu}) \\in \\mathcal{P}{l,r}[\\Omega]  \\Big}          \\end{align}     \\end{subequations} $ where k = l + r is the order of up approximation in the original coupling strengths. We explain the details of the calculation in the following sections, but for now we will just assume these are given to us based on the original Hamiltonian, as illustrated in the figure, for example by the symbolic software package we developed \\textbf{QuantumGraining.jl}, as illustrated in the figure. The full explicit calculation up to second-order is shown in the appendix \\ref{app:rabi-modelcontractioncoefficients}. ","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"In order to effectively capture the coarse-grained dynamics of the Rabi model, we apply the TCG perturbation theory up to the third order and derive the corresponding master equation. In particular, we will see that the TCG procedure reproduces the RWA Hamiltonian at the first-order, and goes beyond it starting at the second-order. ","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"The TCG prduces many different terms, but the high-frequency contributions would be exponentially suppressed by the filter function f(omega). Ignoring these exponentially suppressed terms, we find the most significant effective Hamiltonian terms to be, $     \\begin{equation}     \\hat{H}{\\rm TCG}^{(2)}     \\approx     \\hat{H}{\\rm{RWA}}     +     \\frac{g^{2}}{8} \\Big     \\frac{1}{2\\omega{a}}     -     \\big(     \\tau^{2}     +     \\frac{1}{4\\omega{a}^{2}}     \\big) (\\omega{c} - \\omega{a})     \\Big \\cdot \\hat{\\sigma}z     \\end{equation} $ if we work in the limit where \\frac{1}{\\omega{a}} \\ll \\tau \\ll \\frac{1}{\\abs{\\omega{c}-\\omega{a}}}, \\frac{2}{g}$. ","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"The exact form of these corrections can be obtained using the QuantumGraining.jl package. Note that up to first-order, we get exactly the RWA Hamiltonian, $ \\begin{equation} \\begin{split}     \\hat{H}{\\textrm{RWA}}     =&     \\frac{g}{2}     e^{-\\frac{(\\omega{a}-\\omega{c})^{2}\\tau^{2}}{2}}     \\Big(     e^{i(\\omega{a}-\\omega{c})t} \\hat{a} \\hat{\\sigma}{+}     +     e^{-i(\\omega{a}-\\omega{c})t} \\hat{a}^{\\dagger} \\hat{\\sigma}{-}     \\Big)\\\n    \\approx&     \\frac{g}{2}     \\Big(     e^{i(\\omega{a}-\\omega{c})t} \\hat{a} \\hat{\\sigma}{+}     +     e^{-i(\\omega{a}-\\omega{c})t} \\hat{a}^{\\dagger} \\hat{\\sigma}_{-}     \\Big). \\end{split} \\end{equation} $ Note the appearance of a filter-dependent correction already at this order, which is an important difference from the standard RWA. Unlike the RWA, here the coarse-graining time-scale is a tunable parameter, to be determined by the experimental apparatus. Generally, the filter functions would be determined by the measurement apparatus, but for simplicity here we chose a Gaussian filter with a coarse-graining time-scale tau.","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"A unique property of our TCG method is that it also produces non-unitary contributions to the dynamics. In second-order, we also get the following set of pseudo-dissipators in addition to the dispersive correction in the Hamiltonian, $ \\begin{subequations}     \\begin{align}     \\hat{L}1 &= \\hat{J}1 = \\hat{a} \\hat{\\sigma}+ &     \\gamma1 &= - i \\frac{g^2 \\tau^2}{2} (\\omegac - \\omegaa) e^{-2i(\\omegac - \\omegaa) t} \\\n    \\hat{L}2 &= \\hat{J}2 = \\hat{a}^\\dagger \\hat{\\sigma}- &     \\gamma2 &= i \\frac{g^2 \\tau^2}{2} (\\omegac - \\omegaa) e^{2i(\\omegac - \\omegaa) t}. \\end{align} \\end{subequations} $ These contributions are unique to the TCG method, and are not included in effective static Hamiltonian methods. Notice that the coefficients gamma_1 and gamma_2 are purely imaginary, so the corresponding pseudo-dissipators do not break the time reversal symmetry (hence the prefix ``pseudo-''). In addition, we do not expect significant secular effects from the second-order pseudo-dissipators since their coefficients are oscillatory at frequency pm 2(omega_c - omega_a) and vanish in the resonant limit when omega_c rightarrow omega_a. In particular, they do not induce any secular gain or loss of the system energy, but rather only add small fluctuating corrections (micro-oscillations) to the entropy and energy of the system.","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"However, this is not the case for higher-order corrections in general. For example, looking at the third order contributions, $ \\begin{equation} \\begin{split}     \\lim{\\omega{c} \\rightarrow \\omega{a}}     \\hat{H}{\\textrm{TCG}}^{(3)}     \\approx     \\lim{\\omega{c} \\rightarrow \\omega{a}}     \\hat{H}{\\textrm{TCG}}^{(2)}     -     \\frac{g^{3}}{32 \\omega{a}^{2}} \\hat{a}^{\\dagger} \\hat{a} \\hat{a}^{\\dagger} \\hat{\\sigma}{-}     +     h.c.     \\end{split}     \\end{equation}     and     \\begin{equation}     \\begin{split}     \\lim{\\omega{c} \\rightarrow \\omega{a}}     \\hat{D}{\\textrm{TCG}}^{(3)}     \\approx     \\frac{i g^{3}}{32 \\omega{a}^{2}}     \\Big(     \\mathcal{D}[\\hat{a}^{2} \\hat{\\sigma}{z}, \\hat{a}^{\\dagger} \\hat{\\sigma}{+}]     -     \\mathcal{D}[\\hat{a}^{\\dagger 2} \\hat{\\sigma}{z}, \\hat{a} \\hat{\\sigma}{-}]     \\Big)     +     h.c. \\end{split} \\end{equation} $ we see that both the unitary and non-unitary contributions both give rise to time-independent corrections to the Jaynes-Cummings model in the resonant limit. From the numerical simulation in Fig.\\ref{fig:rabi-models} (obtained with a coarse-graining time scale of tau = 02 textrmns), we see that they both have secular effects on the collapse and revival of spin-state population. In particular, although \\hat{D}{\\textrm{TCG}}^{(3)}$ does not cause any dissipation of energy over long periods of time due to its purely imaginary pre-factor, it does have observable secular effects on the \\textbf{coherence }of the spin, which affects the collapse-revival pattern of the spin-state population. For example, both the RWA (first-order TCG) and the third-order TCG Hamiltonians make the false prediction of a double-revival pattern between t=15textrmns and t=35textrmns, which is removed by including the third-order pseudo-dissipators in hatD_textrmTCG^(3); in addition, adding those pseudo-dissipators also makes the resulting TCG dynamics closer to the one obtained by directly coarse-graining the exact dynamics, as can be observed in \\ref{fig:rabi-models}.  It is also important to emphasize that the TCG master equations can be numerically simulated with much larger time steps without encountering any stiffness problems compared to the exact von-Neumann equation which contains fast-oscillating counter-rotating terms. Therefore, the TCG master equation not only offers analytical insights into the physics of an interacting system, but also allows much more efficient numerical simulation of the dynamics. ","category":"page"},{"location":"theory/","page":"A brief example - The Rabi-model","title":"A brief example - The Rabi-model","text":"In this example, we have treated the method as black-box, producing a new effective description that approximates the time-coarse grained dynamics. In the following sections, we will delve into how the method works in more detail.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumGraining.jl offers a practical, generalized approach to the time-coarse graining (TCG) method in quantum optics. Often in quantum optics, we are not interested in the short time-scale dynamics – they are either trivial, or unmeasurable, and keeping track of them is very computationally expensive. The time-coarse graning approach gives an effective description for the time-coarse grained dynamics, while preserving the slow time-scale effects of the short time-scale dynamics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The main challenge with the TCG approach is that the calculations are very involved, with the number of terms growing rapidly with the order of truncation. QuantumGraining.jl automates this process, representing the effective Lindbladians in terms of abstract operators that are easily integrated into other symbolic packages, such as QuantumCumulants.jl and QuantumOptics.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The model (Hamiltonian) is specified, along with the time-coarse graining time-scale.\nThe effective Lindbladian is calculated, using an efficient, recursive approach. The resulting Lindbladian is stored stored as a symbolic expression using the Symbolics.jl framework, which is also used for any additional simplification and rewriting.\nFinally, the symbolic Hamiltonian can be solved in QuantumOptics.jl or using QuantumCumulants.jl. ","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumGraining.jl is in early stages of developemnt, and is still not registered in the Julia package registrator. For the time being, the package can be installed by cloning the repository from GitHub.  To install QuantumGraining.jl, follow these steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Clone the repository from GitHub:  git clone https://github.com/leonbello/QuantumGraining.jl.git\nOpen the Julia package manager by running julia in your terminal.\nActivate the package by entering the package manager mode with ].\nChange to the QuantumGraining.jl directory:  cd /path/to/QuantumGraining.jl\nActivate the package environment:  activate .\nBuild the package and its dependencies:  instantiate\nExit the package manager mode by pressing Ctrl + C.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"After following these steps, you should have successfully installed QuantumGraining.jl and its dependencies.","category":"page"},{"location":"#Development-Status","page":"Introduction","title":"Development Status","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that QuantumGraining.jl is still at an early stage of development.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Build Status)","category":"page"},{"location":"#Short-example","page":"Introduction","title":"Short example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As a simple illustrative example, let us consider the implementation of a second-order time coarse graining of the Rabi model:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using QuantumCumulants\nusing QuantumGraining\n\n@variables g ωc ωa\nΩ = [-ωc - ωa, ωc + ωa, -ωc + ωa, ωc - ωa]\ngvec = (g/2).*[1, 1, 1, 1]\n\n# Hilbert space definitions (QuantumCumulants.jl)\nh_cav = FockSpace(:cavity)\nh_atom = NLevelSpace(:atom, (:g,:e))\nh = tensor(h_cav, h_atom)\n\n# Operator definitions\n@qnumbers a::Destroy(h) σ::Transition(h)\nσm = σ(:e, :g)\nσp = σ(:g, :e)\nhvec = [a*σm, a'*σp, a*σp, a'*σm]\n\norder=2\ng_eff, Ω_eff = drop_high_freqs(effective_hamiltonian(hvec, gvec, Ω, order; as_dict=true)..., Dict(ωa => 1, ωc => 1.01))\nγ_eff, ω_eff = drop_high_freqs(effective_dissipator(hvec, gvec, Ω, order)..., Dict(ωa => 1, ωc => 1.01)) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The code above returns an effective Lindbladian that generates the time-coarse grained evolution of the Rabi-model up to second-order. The input is a list of frequencies and their corresponding operators, and the output is a new list of operators, frequencies and coupling strengths. The drop_high_freqs function is used to remove the high-frequency terms from the effective Hamiltonian and dissipator, to simplify the resulting expressions.","category":"page"},{"location":"tutorial/#Short-example","page":"-","title":"Short example","text":"","category":"section"},{"location":"tutorial/","page":"-","title":"-","text":"As a simple illustrative example, let us consider the implementation of a second-order time coarse graining of the Rabi model:","category":"page"},{"location":"tutorial/","page":"-","title":"-","text":"using QuantumCumulants\nusing QuantumGraining\n\n@variables g ωc ωa\nΩ = [-ωc - ωa, ωc + ωa, -ωc + ωa, ωc - ωa]\ngvec = (g/2).*[1, 1, 1, 1]\n\n# Hilbert space definitions (QuantumCumulants.jl)\nh_cav = FockSpace(:cavity)\nh_atom = NLevelSpace(:atom, (:g,:e))\nh = tensor(h_cav, h_atom)\n\n# Operator definitions\n@qnumbers a::Destroy(h) σ::Transition(h)\nσm = σ(:e, :g)\nσp = σ(:g, :e)\nhvec = [a*σm, a'*σp, a*σp, a'*σm]\n\norder=2\ng_eff, Ω_eff = drop_high_freqs(effective_hamiltonian(hvec, gvec, Ω, order; as_dict=true)..., Dict(ωa => 1, ωc => 1.01))\nγ_eff, ω_eff = drop_high_freqs(effective_dissipator(hvec, gvec, Ω, order)..., Dict(ωa => 1, ωc => 1.01)) ","category":"page"},{"location":"tutorial/","page":"-","title":"-","text":"The code above returns an effective Lindbladian that generates the time-coarse grained evolution of the Rabi-model up to second-order. The input is a list of frequencies and their corresponding operators, and the output is a new list of operators, frequencies and coupling strengths. The drop_high_freqs function is used to remove the high-frequency terms from the effective Hamiltonian and dissipator, to simplify the resulting expressions.","category":"page"}]
}
