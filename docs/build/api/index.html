<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumGraining.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumGraining.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../theory/">A brief example - The Rabi-model</a></li><li><a class="tocitem" href="../tutorial/">-</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#API:-BVector"><span>BVector</span></a></li><li><a class="tocitem" href="#API:-Diagrams"><span>Diagrams</span></a></li><li><a class="tocitem" href="#API:-Poles"><span>Poles</span></a></li><li><a class="tocitem" href="#API:-Contractions"><span>Contractions</span></a></li><li><a class="tocitem" href="#API:-Corrections"><span>Corrections</span></a></li><li><a class="tocitem" href="#API:-Bubble"><span>Bubble</span></a></li><li><a class="tocitem" href="#API:-Lindblad"><span>Lindblad</span></a></li><li><a class="tocitem" href="#API:-Printing"><span>Printing</span></a></li><li><a class="tocitem" href="#API:-Convert"><span>Convert</span></a></li><li><a class="tocitem" href="#API:-Ordering"><span>Ordering</span></a></li></ul></li><li><span class="tocitem">Examples</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/leonbello/QuantumGraining.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="API:-BVector"><a class="docs-heading-anchor" href="#API:-BVector">BVector</a><a id="API:-BVector-1"></a><a class="docs-heading-anchor-permalink" href="#API:-BVector" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.DVec" href="#QuantumGraining.DVec"><code>QuantumGraining.DVec</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&quot;     DVec(u::Vector; special=false) Creates a BVector with type :down. Assumes the frequency ordering is clockwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/bvector.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.UVec" href="#QuantumGraining.UVec"><code>QuantumGraining.UVec</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&quot;     UVec(u::Vector; special=false) Creates a BVector with type :up. Assumes the frequency ordering is clockwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/bvector.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.BVector" href="#QuantumGraining.BVector"><code>QuantumGraining.BVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BVector{T} &lt;: AbstractVector{T}</code></pre><p>A struct representing the up- or down-modes. The poles are stored in the poles field.</p><p>Arguments:     - freqs: A vector representing the frequencies of the vector.     - poles: A vector of the indices of poles of the vector, if any. Does not include the special mode, if there is one.     - special: A boolean representing whether the vector is the special mode.     - type: A symbol representing the type of the vector. Must be :up or :down.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/bvector.jl#L1-L10">source</a></section></article><h2 id="API:-Diagrams"><a class="docs-heading-anchor" href="#API:-Diagrams">Diagrams</a><a id="API:-Diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Diagrams" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.DiagramNode" href="#QuantumGraining.DiagramNode"><code>QuantumGraining.DiagramNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiagramNode</code></pre><p>The DiagramNode struct is a type for one bubble in the diagram.  It is defined as a recursive tree where the elements represent the different decompositions of one node into two. </p><p><strong>Fields:</strong></p><ul><li><code>root::Tuple{Int, Int}</code>: The root of the tree, the largest common bubble defining the contraction.</li><li><code>val::Tuple{Int, Int}</code>: The value of the current node, determines how much of the bubble was broken to the left.</li><li><code>rightmost::Tuple{Int, Int}</code>: The value of the rightmost bubble.</li><li><code>right::DiagramNode</code>: Pointer to the next right node of the tree, a diagram with one mode broken to the down-bubble.</li><li><code>left::DiagramNode</code>: Pointer to the next left node of the tree, a diagram with one mode broken to the up-bubble.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/diagrams.jl#L19-L31">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>node_decomp</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.get_diagrams" href="#QuantumGraining.get_diagrams"><code>QuantumGraining.get_diagrams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_diagrams(init_diagram::Array)</code></pre><p>Uses the above <code>node_decomp()</code> to get all possible diagrams recursively.</p><p><strong>Arguments</strong></p><ul><li><code>node::AbstractDiagramNode</code>: The initial diagram including the first level of breakdowns (two bubble diagrams)</li></ul><p><strong>Returns</strong></p><ul><li>A list of all possible diagrams for a given contractions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/diagrams.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.Diagram" href="#QuantumGraining.Diagram"><code>QuantumGraining.Diagram</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Diagram{T1, T2} &lt;: AbstractVector{Tuple{T1, T2}}</code></pre><p>A struct representing a diagram, also takes care of the edge mode.</p><p>Arguments:     - bubbles: A vector of bubbles.     - freqs: A vector of tuples of BVectors. The first element of the tuple is the up-bubble, the second is the down-bubble.     - shape: A vector of tuples representing the shape of the bubbles.     - up<em>poles: A vector of vectors representing the up-poles of the bubbles.     - down</em>poles: A vector of vectors representing the down-poles of the bubbles.     - num_poles: An integer representing the number of poles in the diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/diagram.jl#L1-L12">source</a></section></article><h2 id="API:-Poles"><a class="docs-heading-anchor" href="#API:-Poles">Poles</a><a id="API:-Poles-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Poles" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Contraction</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.count_poles" href="#QuantumGraining.count_poles"><code>QuantumGraining.count_poles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_poles(s_list::Vector{Int}, stag_list::Vector{Int})</code></pre><p>Given two lists of poles, counts the total number of poles by counting the non-empty lists.</p><p>Argument:      - s<em>list: list of upper poles     - stag</em>list: list of lower poles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/poles.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.find_poles" href="#QuantumGraining.find_poles"><code>QuantumGraining.find_poles</code></a> — <span class="docstring-category">Function</span></header><section><div><p>find_poles(u)</p><p>Finds all the factors of the vector factorial that evaluate to 0.</p><p>Argument:      - ω = [(μ<em>1, ν</em>1), ..., (μ<em>||d||, ν</em>||d||)]</p><p>Returns:     - poles_list: list of indices of poles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/poles.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.find_all_poles" href="#QuantumGraining.find_all_poles"><code>QuantumGraining.find_all_poles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_all_poles(d::Vector{Tuple{BVector{T1}, BVector{T2}}}) where {T1, T2}</code></pre><p>Find all poles in the given vector of tuples <code>d</code>. Each tuple contains two <code>BVector</code> objects, <code>μ</code> and <code>ν</code>. The function iterates over each tuple and performs the following steps:</p><ul><li>If <code>μ.special</code> is <code>true</code>, it removes the first element from <code>μ</code>.</li><li>Reverses the order of elements in <code>μ</code>.</li><li>Calls the <code>find_poles</code> function to find the poles in <code>μ</code> and <code>ν</code>.</li><li>Appends the resulting poles to <code>up_poles</code> and <code>down_poles</code> respectively.</li></ul><p><strong>Arguments</strong></p><ul><li><code>d::Vector{Tuple{BVector{T1}, BVector{T2}}}</code>: A vector of tuples, where each tuple contains two <code>BVector</code> objects.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(up_poles, down_poles)</code> where <code>up_poles</code> is a vector of vectors containing the poles found in <code>μ</code>, and <code>down_poles</code> is a vector of vectors containing the poles found in <code>ν</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/poles.jl#L52-L69">source</a></section><section><div><pre><code class="nohighlight hljs">find_all_poles(d::Vector{Tuple{Vector{T1}, Vector{T2}}}) where {T1, T2}</code></pre><p>Finds all poles in vector factorial for frequency list <code>d</code>. Assumes that the first tuple in the list is the special mode.</p><p>Argument:      - ω = [(μ<em>1, ν</em>1), ..., (μ<em>||d||, ν</em>||d||)] Returns:     - up<em>poles: list of indices of poles in upper modes     - down</em>poles: list of indices of poles in lower modes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/poles.jl#L84-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.find_integer_solutions" href="#QuantumGraining.find_integer_solutions"><code>QuantumGraining.find_integer_solutions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_integer_solutions(num_vars::Int, target_sum::Int, combination::Vector{Int}=Vector{Int}(), sum_so_far::Int=0)</code></pre><p>Function that calculates combinations of k positive integers adding up to m, as detailed in the paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/poles.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.reshape_sols" href="#QuantumGraining.reshape_sols"><code>QuantumGraining.reshape_sols</code></a> — <span class="docstring-category">Function</span></header><section><div><p>reshape<em>sols(sols, target</em>sum, num<em>bubbles, num</em>indices = 3)</p><p>Helper function that reshapes integer combinations from find<em>integer</em>solutions() into vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/poles.jl#L145-L149">source</a></section></article><h2 id="API:-Contractions"><a class="docs-heading-anchor" href="#API:-Contractions">Contractions</a><a id="API:-Contractions-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Contractions" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>diagram_correction</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>contraction_coeff</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>calc_pole_corrections</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.Correction" href="#QuantumGraining.Correction"><code>QuantumGraining.Correction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Correction</code></pre><p>A struct representing a correction term.</p><p><strong>Fields</strong></p><ul><li><code>prefac</code>: The prefactor of the correction term.</li><li><code>exponent</code>: The exponent of the correction term.</li><li><code>poly</code>: A vector of coefficients for the polynomial term.</li><li><code>order</code>: The order of the polynomial term.</li></ul><p><strong>Constructors</strong></p><ul><li><code>Correction(prefac, exponent, poly=Num[1,], order=length(poly))</code>: Constructs a <code>Correction</code> object with the given parameters. If <code>poly</code> is not provided, it defaults to <code>[1]</code>. If <code>order</code> is not provided, it defaults to the length of <code>poly</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/corrections.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.ContractionCoefficient" href="#QuantumGraining.ContractionCoefficient"><code>QuantumGraining.ContractionCoefficient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ContractionCoefficient</code></pre><p>A struct representing a contraction coefficient.</p><p><strong>Fields</strong></p><ul><li><code>corrections::Vector{Correction}</code>: Vector of <code>Correction</code> objects.</li><li><code>exponents::Vector{Number}</code>: Vector of exponents.</li><li><code>prefacs::Vector{Number}</code>: Vector of prefactors.</li><li><code>polys::Vector{Vector{Number}}</code>: Vector of polynomials.</li></ul><p><strong>Constructors</strong></p><ul><li><code>ContractionCoefficient(exponents, prefacs, polys)</code>: Constructs a <code>ContractionCoefficient</code> object with given exponents, prefactors, and polynomials.</li><li><code>ContractionCoefficient(exponents, prefacs)</code>: Constructs a <code>ContractionCoefficient</code> object with given exponents and prefactors. Polynomials are set to <code>[1]</code> by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/corrections.jl#L43-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.split_freqs_into_bubbles" href="#QuantumGraining.split_freqs_into_bubbles"><code>QuantumGraining.split_freqs_into_bubbles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split_freqs_into_bubbles(freqs, diagram)</code></pre><p>Splits an array of frequencies into an array of tuples of frequencies, matching the dimensions of each bubble in <code>diagram</code>.</p><p>Argument:     freqs - an array of frequencies in the form ω = [μ1..., μ2..., ..., μl..., ν1..., ν2..., ..., νr]     diagram - dimensions of each bubble, where each tuple is the dimension for the corresponding bubble. Returns:     ω - an array of frequencies in the form [(μ1, ν1), (μ2, ν2), ..., (μl, νl), ([], ν(l+1)), ..., ([], νr)]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/contractions.jl#L4-L13">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>to_qc_symbol</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="API:-Corrections"><a class="docs-heading-anchor" href="#API:-Corrections">Corrections</a><a id="API:-Corrections-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Corrections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.merge_duplicate_exponents" href="#QuantumGraining.merge_duplicate_exponents"><code>QuantumGraining.merge_duplicate_exponents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">merge_duplicate_exponents(c::ContractionCoefficient)</code></pre><p>Merge duplicate exponents in a <code>ContractionCoefficient</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>c::ContractionCoefficient</code>: The <code>ContractionCoefficient</code> object to merge duplicate exponents.</li></ul><p><strong>Returns</strong></p><p>A new <code>ContractionCoefficient</code> object with merged duplicate exponents.</p><p><strong>Description</strong></p><p>This function takes a <code>ContractionCoefficient</code> object and merges any duplicate exponents. It iterates over the exponents, prefactors, and polynomials in the <code>ContractionCoefficient</code> object and checks for duplicates.  If duplicates are found, the prefactors and polynomials are merged into a single polynomial.  The resulting unique exponents, merged prefactors, and merged polynomials are then used to create a new <code>ContractionCoefficient</code> object.</p><p>Note that the function uses the <code>ordered_sum</code> function to merge the polynomials and the <code>simplify</code> function to simplify the resulting polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/corrections.jl#L480-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.simplify_contraction" href="#QuantumGraining.simplify_contraction"><code>QuantumGraining.simplify_contraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplify_contraction(c::ContractionCoefficient)</code></pre><p>Simplifies the given <code>ContractionCoefficient</code> by applying simplification operations to its components.</p><p><strong>Arguments</strong></p><ul><li><code>c::ContractionCoefficient</code>: The <code>ContractionCoefficient</code> to be simplified.</li></ul><p><strong>Returns</strong></p><p>A new <code>ContractionCoefficient</code> object with simplified components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/corrections.jl#L83-L94">source</a></section></article><h2 id="API:-Bubble"><a class="docs-heading-anchor" href="#API:-Bubble">Bubble</a><a id="API:-Bubble-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Bubble" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.Bubble" href="#QuantumGraining.Bubble"><code>QuantumGraining.Bubble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bubble{T1, T2} &lt;: AbstractVector{Tuple{T1, T2}}</code></pre><p>A struct representing a bubble, also takes care of the edge case.</p><p>Arguments:     - up: A BVector representing the up-bubble.     - down: A BVector representing the down-bubble.     - shape: A tuple representing the shape of the bubble.     - special: A boolean representing whether the bubble is a special edge mode bubble.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/bubble.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.calculate_bubble_factor" href="#QuantumGraining.calculate_bubble_factor"><code>QuantumGraining.calculate_bubble_factor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_bubble_factor(ω, bubble_idx, total_num_poles, s, stag)</code></pre><p>Returns the bubble factor for a single bubble.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `ω`: the frequency values for the whole diagram.
- `total_num_poles`: the total number of singular poles in the diagram
- `bubble_idx`: the index of the bubble for which we want to calculate the correction factor.
- `s`: a list of the singular poles in the upper modes of the bubble.
- `stag`: a list of the singular poles in the lower modes of the bubble.</code></pre><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">- an array of all bubble factors.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/contractions.jl#L222-L235">source</a></section></article><h2 id="API:-Lindblad"><a class="docs-heading-anchor" href="#API:-Lindblad">Lindblad</a><a id="API:-Lindblad-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Lindblad" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.effective_hamiltonian_term" href="#QuantumGraining.effective_hamiltonian_term"><code>QuantumGraining.effective_hamiltonian_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">effective_hamiltonian(h::Vector, g::Vector{Number}, Ω::Vector{Number}, k::Int)</code></pre><p>Given a truncation order <code>k</code>, a list of frequencies <code>Ω</code>, couplings <code>g</code>, and operators <code>h</code> representing the raw Hamiltonian,  this function returns new frequencies, coupling strengths, and operators representing the Hamiltonian to order <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>h::Vector</code>: A vector of operators representing the raw Hamiltonian.</li><li><code>g::Vector{Number}</code>: A vector of coupling strengths.</li><li><code>Ω::Vector{Number}</code>: A vector of frequencies.</li><li><code>k::Int</code>: The truncation order.</li></ul><p><strong>Returns</strong></p><ul><li><code>ops_eff::Vector</code>: A vector of operators representing the effective Hamiltonian to order <code>k</code>.</li><li><code>merged_gs::Vector</code>: A vector of merged coupling strengths.</li><li><code>ωs_eff::Vector</code>: A vector of frequencies representing the effective Hamiltonian to order <code>k</code>.</li></ul><p><strong>Details</strong></p><p>The function calculates the effective Hamiltonian by considering all possible combinations of operators, frequencies, and coupling strengths up to order <code>k</code>.  It simplifies the expressions and merges duplicate coupling strengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L82-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.effective_dissipator_term" href="#QuantumGraining.effective_dissipator_term"><code>QuantumGraining.effective_dissipator_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">effective_dissipator_term(h::Vector, gs::Vector, Ω::Vector, k::Int)</code></pre><p>Compute the effective dissipator term for a given set of parameters.</p><p><strong>Arguments</strong></p><ul><li><code>h::Vector</code>: Vector of coefficients for the Hamiltonian terms.</li><li><code>gs::Vector</code>: Vector of coefficients for the jump operators.</li><li><code>Ω::Vector</code>: Vector of coefficients for the frequencies.</li><li><code>k::Int</code>: Number of terms in the Hamiltonian.</li></ul><p><strong>Returns</strong></p><ul><li><code>J_list::Vector</code>: Vector of tuples representing the jump operators.</li><li><code>γ_list::Vector</code>: Vector of complex numbers representing the dissipation coefficients.</li><li><code>ω_list::Vector</code>: Vector of sums of frequencies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L220-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.repeated_combinations" href="#QuantumGraining.repeated_combinations"><code>QuantumGraining.repeated_combinations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">repeated_combinations(arr::Array, n::Int)</code></pre><p>Given a collection of terms and a number <code>n</code>, returns all possible <code>n</code> repetitions of the elements in the collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L7-L11">source</a></section><section><div><pre><code class="nohighlight hljs">repeated_combinations(h::Vector, g::Vector, Ω::Vector, n::Int)</code></pre><p>Generate all possible combinations of elements from the input vectors <code>h</code>, <code>g</code>, and <code>Ω</code> with repetition, forming combinations of length <code>n</code>.</p><p><strong>Arguments</strong></p><ul><li><code>h::Vector</code>: Vector of elements for combination from <code>h</code></li><li><code>g::Vector</code>: Vector of elements for combination from <code>g</code></li><li><code>Ω::Vector</code>: Vector of elements for combination from <code>Ω</code></li><li><code>n::Int</code>: Length of combinations to generate</li></ul><p><strong>Returns</strong></p><ul><li><code>perm_h::Vector</code>: Vector of combinations of elements from <code>h</code></li><li><code>perm_g::Vector</code>: Vector of combinations of elements from <code>g</code></li><li><code>perm_Ω::Vector</code>: Vector of combinations of elements from <code>Ω</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L37-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.gaussian_to_cutoff" href="#QuantumGraining.gaussian_to_cutoff"><code>QuantumGraining.gaussian_to_cutoff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussian_to_cutoff(gs, freq_vals; cutoff=0.1, keep_small_exponents=true)</code></pre><p>Apply a cutoff to Gaussian exponents based on their absolute value.</p><p><strong>Arguments</strong></p><ul><li><code>gs</code>: A list of <code>ContractionCoefficient</code> objects representing Gaussian functions.</li><li><code>freq_vals</code>: A dictionary mapping frequency keys to their corresponding values.</li><li><code>cutoff</code>: The cutoff value for the absolute value of the Gaussian exponents. Default is <code>0.1</code>.</li><li><code>keep_small_exponents</code>: A boolean indicating whether to keep small exponents or set them to zero. Default is <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A list of <code>ContractionCoefficient</code> objects with the cutoff applied to the Gaussian exponents.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L370-L384">source</a></section><section><div><pre><code class="nohighlight hljs">gaussian_to_cutoff(gs::Dict, ωs::Dict, freq_vals; cutoff=0.1, keep_small_exponents=true)</code></pre><p>Apply a cutoff to Gaussian exponents based on their absolute value.</p><p><strong>Arguments</strong></p><ul><li><code>gs</code>: A dictionary mapping frequency keys to <code>ContractionCoefficient</code> objects representing Gaussian functions.</li><li><code>ωs</code>: A dictionary mapping frequency keys to their corresponding values.</li><li><code>freq_vals</code>: A dictionary mapping frequency keys to their corresponding values.</li><li><code>cutoff</code>: The cutoff value for the absolute value of the Gaussian exponents. Default is <code>0.1</code>.</li><li><code>keep_small_exponents</code>: A boolean indicating whether to keep small exponents or set them to zero. Default is <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary mapping frequency keys to <code>ContractionCoefficient</code> objects with the cutoff applied to the Gaussian exponents.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L402-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.drop_high_freqs" href="#QuantumGraining.drop_high_freqs"><code>QuantumGraining.drop_high_freqs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drop_high_freqs(freqs_list::Vector, freqs_subs, cutoff=0.1)</code></pre><p>Given a list of frequencies and a list of substitutions, returns only the low frequencies.</p><p><strong>Arguments</strong></p><ul><li><code>freqs_list::Vector</code>: A list of frequencies.</li><li><code>freqs_subs</code>: A list of substitutions.</li><li><code>cutoff=0.1</code>: The cutoff value for determining low frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>rwa</code>: A list of indices corresponding to the low frequencies.</li><li><code>freqs_low</code>: A list of low frequencies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L316-L329">source</a></section><section><div><pre><code class="nohighlight hljs">drop_high_freqs(gs_dict, freqs_dict, freqs_vals; cutoff=0.1)</code></pre><p>Given dictionaries holding the frequencies and couplings, drops all high-frequency contributions.</p><p><strong>Arguments</strong></p><ul><li><code>gs_dict</code>: A dictionary holding the coupling strengths.</li><li><code>freqs_dict</code>: A dictionary holding the frequencies.</li><li><code>freqs_vals</code>: A dictionary of substitutions for the frequencies.</li><li><code>cutoff=0.1</code>: The cutoff value for determining high frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>gs_dict</code>: The updated dictionary of coupling strengths after dropping high-frequency contributions.</li><li><code>freqs_dict</code>: The updated dictionary of frequencies after dropping high-frequency contributions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L344-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.effective_hamiltonian" href="#QuantumGraining.effective_hamiltonian"><code>QuantumGraining.effective_hamiltonian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">effective_hamiltonian(h::Vector, gs::Vector, Ω::Vector, k::Int; as_dict=false, remove_constants=true)</code></pre><p>Compute the effective Hamiltonian for a given system.</p><p><strong>Arguments</strong></p><ul><li><code>h::Vector</code>: A vector of Hamiltonian terms.</li><li><code>gs::Vector</code>: A vector of coupling strengths.</li><li><code>Ω::Vector</code>: A vector of frequencies.</li><li><code>k::Int</code>: The number of terms to consider.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>as_dict::Bool=false</code>: If <code>true</code>, the output will be returned as a dictionary of operators and frequencies.</li><li><code>remove_constants::Bool=true</code>: If <code>true</code>, remove constant terms from the output.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>as_dict</code> is <code>true</code>, returns a tuple <code>(gs_eff, ωs_eff)</code> where <code>gs_eff</code> is a dictionary of operators and <code>ωs_eff</code> is a dictionary of frequencies.</li><li>If <code>as_dict</code> is <code>false</code>, returns a tuple <code>(unique_hs, unique_gs, ωs_eff)</code> where <code>unique_hs</code> is a vector of unique operators, <code>unique_gs</code> is a vector of unique coupling strengths, and <code>ωs_eff</code> is a vector of frequencies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L138-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.effective_dissipator" href="#QuantumGraining.effective_dissipator"><code>QuantumGraining.effective_dissipator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">effective_dissipator(h::Vector, gs::Vector, Ω::Vector, k::Int; as_dict=true)</code></pre><p>Compute the effective dissipator for a given set of parameters.</p><p><strong>Arguments</strong></p><ul><li><code>h::Vector</code>: A vector of operators representing the raw Hamiltonian.</li><li><code>gs::Vector</code>: A vector of coupling strengths.</li><li><code>Ω::Vector</code>: A vector of frequencies.</li><li><code>k::Int</code>: The truncation order.</li><li><code>as_dict::Bool</code>: (optional) If <code>true</code>, returns the dissipator as a dictionary of operators and their corresponding dissipator terms. If <code>false</code>, returns the dissipator as separate vectors for operators, dissipator terms, and frequencies. Default is <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>as_dict</code> is <code>true</code>, returns a tuple <code>(γs_dict, ωs_dict)</code> where <code>γs_dict</code> is a dictionary of operators and their corresponding dissipator terms, and <code>ωs_dict</code> is a dictionary of operators and their corresponding frequencies.</li><li>If <code>as_dict</code> is <code>false</code>, returns a tuple <code>(ops_eff, γs_eff, ωs_eff)</code> where <code>ops_eff</code> is a vector of operators representing the effective dissipator, <code>γs_eff</code> is a vector of dissipator terms, and <code>ωs_eff</code> is a vector of frequencies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/lindblad.jl#L261-L277">source</a></section></article><h2 id="API:-Printing"><a class="docs-heading-anchor" href="#API:-Printing">Printing</a><a id="API:-Printing-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Printing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.symbolic_hamiltonian" href="#QuantumGraining.symbolic_hamiltonian"><code>QuantumGraining.symbolic_hamiltonian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symbolic_hamiltonian(gs::Vector, ops::Vector, Ω::Vector, t, τ)</code></pre><p>Constructs a symbolic Hamiltonian for a quantum system.</p><p><strong>Arguments</strong></p><ul><li><code>gs::Vector</code>: Vector of symbols representing the coefficients of the Hamiltonian terms.</li><li><code>ops::Vector</code>: Vector of operators corresponding to each Hamiltonian term.</li><li><code>Ω::Vector</code>: Vector of frequencies for each Hamiltonian term.</li><li><code>t</code>: Time parameter.</li><li><code>τ</code>: Symbolic time parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>terms</code>: Vector of symbolic Hamiltonian terms.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/printing.jl#L13-L28">source</a></section><section><div><pre><code class="nohighlight hljs">symbolic_hamiltonian(gs::Dict, Ω::Dict, t, τ)</code></pre><p>Constructs a symbolic Hamiltonian for a quantum system.</p><p><strong>Arguments</strong></p><ul><li><code>gs::Dict</code>: A dictionary mapping operators to their corresponding coefficients.</li><li><code>Ω::Dict</code>: A dictionary mapping operators to their corresponding frequencies.</li><li><code>t</code>: The time parameter.</li><li><code>τ</code>: The time step parameter.</li></ul><p><strong>Returns</strong></p><p>A symbolic Hamiltonian for the quantum system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/printing.jl#L46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.to_symbol" href="#QuantumGraining.to_symbol"><code>QuantumGraining.to_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_symbol(coeff::ContractionCoefficient, τ)</code></pre><p>Give a symbolic representation of a <code>ContractionCoefficient</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>coeff::ContractionCoefficient</code>: The <code>ContractionCoefficient</code> object to compute the symbol for.</li><li><code>τ</code>: The value of τ.</li></ul><p><strong>Returns</strong></p><p>Symbolic representation of the <code>ContractionCoefficient</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/printing.jl#L69-L81">source</a></section><section><div><pre><code class="nohighlight hljs">to_symbol(c::Correction, τ)</code></pre><p>Give a symbolic representation of a <code>Correction</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>c::Correction</code>: The <code>Correction</code> object to compute the symbol for.</li><li><code>τ</code>: The value of τ.</li></ul><p><strong>Returns</strong></p><p>Symbolic representation of the <code>Correction</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/printing.jl#L90-L102">source</a></section></article><h2 id="API:-Convert"><a class="docs-heading-anchor" href="#API:-Convert">Convert</a><a id="API:-Convert-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Convert" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>convert_expressions</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.hamiltonian_function" href="#QuantumGraining.hamiltonian_function"><code>QuantumGraining.hamiltonian_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hamiltonian_function(gs, ωs, h_src, h_tgt, ps; return_contraction_functions=false)</code></pre><p>Constructs a Hamiltonian function based on the given parameters for <code>QuantumOptics.jl</code>.</p><p><strong>Arguments</strong></p><ul><li><code>gs</code>: A dictionary of contraction functions, where the keys are quantum numbers and the values are the corresponding contraction functions.</li><li><code>ωs</code>: A dictionary of frequencies, where the keys are quantum numbers and the values are the corresponding frequencies.</li><li><code>h_src</code>: An array of source Hamiltonian operators.</li><li><code>h_tgt</code>: An array of target Hamiltonian operators.</li><li><code>ps</code>: A dictionary of parameters, where the keys are parameter names and the values are the corresponding parameter values.</li><li><code>return_contraction_functions</code>: (optional) A boolean indicating whether to return the contraction functions along with the Hamiltonian function. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>return_contraction_functions</code> is <code>false</code>, returns a Hamiltonian function <code>H_func</code> that takes a time <code>t</code> and a state <code>ψ</code> as input and returns the Hamiltonian operator applied to the state.</li><li>If <code>return_contraction_functions</code> is <code>true</code>, returns a tuple <code>(H_func, func_gs)</code> where <code>H_func</code> is the Hamiltonian function and <code>func_gs</code> is a dictionary of contraction functions, where the keys are quantum numbers and the values are the corresponding contraction functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/convert.jl#L86-L103">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>normal_ordered_dictionary</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>qc_convert</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.qnumber_to_qop" href="#QuantumGraining.qnumber_to_qop"><code>QuantumGraining.qnumber_to_qop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">qnumber_to_qop(qn::QuantumCumulants.QMul, op_subs, Id; mul = tensor)</code></pre><p>Converts a <code>QuantumCumulants.QMul</code> object to a quantum operator.</p><p><strong>Arguments</strong></p><ul><li><code>qn::QuantumCumulants.QMul</code>: The <code>QMul</code> object representing the quantum number.</li><li><code>op_subs</code>: The operator substitutions to be applied.</li><li><code>Id</code>: The identity operator.</li><li><code>mul</code>: The function used for tensor multiplication. Default is <code>tensor</code>.</li></ul><p><strong>Returns</strong></p><p>The quantum operator obtained from the <code>QMul</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/convert.jl#L130-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.contraction_to_function" href="#QuantumGraining.contraction_to_function"><code>QuantumGraining.contraction_to_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contraction_to_function(g, ω, ps)</code></pre><p>Converts a contraction expression <code>g</code> into a Julia function that depends on the variables <code>t</code> and <code>τ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: The contraction expression to be converted.</li><li><code>ω</code>: The angular frequency.</li><li><code>ps</code>: Additional parameters.</li></ul><p><strong>Returns</strong></p><p>A Julia function that represents the contraction expression <code>g</code> as a function of <code>t</code> and <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/convert.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.lindblad_function" href="#QuantumGraining.lindblad_function"><code>QuantumGraining.lindblad_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lindblad_function(gs, Ωs, γs, ωs, h_src, h_tgt, ps)</code></pre><p>Constructs a Lindblad function that represents the Lindblad master equation for a quantum system.</p><p><strong>Arguments</strong></p><ul><li><code>gs</code>: An array of complex numbers representing the coupling strengths between the system and the environment.</li><li><code>Ωs</code>: An array of complex numbers representing the Rabi frequencies of the system.</li><li><code>γs</code>: An array of tuples representing the jump operators and their corresponding decay rates.</li><li><code>ωs</code>: A dictionary mapping jump operators to their corresponding frequencies.</li><li><code>h_src</code>: An array of quantum operators representing the source Hamiltonian.</li><li><code>h_tgt</code>: An array of quantum operators representing the target Hamiltonian.</li><li><code>ps</code>: A dictionary mapping jump operators to their corresponding probabilities.</li></ul><p><strong>Returns</strong></p><p>A function <code>L_func</code> that represents the Lindblad master equation for the given quantum system for <code>QuantumOptics.jl</code>.</p><p>The Lindblad master equation is given by:     dρ/dt = -i[H(t, ρ), ρ] + ∑(J * ρ * J† - 0.5 * (J† * J * ρ + ρ * J† * J)) where <code>H(t, ρ)</code> is the time-dependent Hamiltonian, <code>ρ</code> is the density matrix, <code>J</code> is the jump operator, and <code>J†</code> is the adjoint of the jump operator.</p><p>The function <code>L_func</code> takes two arguments: <code>t</code> (time) and <code>ρ</code> (density matrix), and returns a tuple <code>(H, J, J†, rates)</code>. <code>H</code> is the time-dependent Hamiltonian, <code>J</code> is an array of jump operators, <code>J†</code> is an array of adjoints of the jump operators, and <code>rates</code> is an array of decay rates.</p><p>The Lindblad function can be used to simulate the time evolution of a quantum system under the influence of the environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/convert.jl#L31-L56">source</a></section></article><h2 id="API:-Ordering"><a class="docs-heading-anchor" href="#API:-Ordering">Ordering</a><a id="API:-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Ordering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.expand_operators" href="#QuantumGraining.expand_operators"><code>QuantumGraining.expand_operators</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_operators(hs)</code></pre><p>Expand a list of operators by applying the <code>expand_operator</code> function to each operator.</p><p><strong>Arguments</strong></p><ul><li><code>hs</code>: A list of operators to be expanded.</li></ul><p><strong>Returns</strong></p><p>A list of expanded operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/ordering.jl#L5-L16">source</a></section><section><div><pre><code class="nohighlight hljs">expand_operators(hs, gs, ωs)</code></pre><p>Goes over any sum of operators and breaks it into the constituent operators while preserving the order of the other vectors.</p><p><strong>Arguments</strong></p><ul><li><code>hs</code>: Array of operators to be expanded.</li><li><code>gs</code>: Array of coefficients corresponding to the operators.</li><li><code>ωs</code>: Array of weights corresponding to the operators.</li></ul><p><strong>Returns</strong></p><ul><li><code>unique_hs</code>: Array of expanded operators.</li><li><code>unique_gs</code>: Array of coefficients corresponding to the expanded operators.</li><li><code>unique_ωs</code>: Array of weights corresponding to the expanded operators.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/ordering.jl#L28-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.expand_operator" href="#QuantumGraining.expand_operator"><code>QuantumGraining.expand_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_operator(h)</code></pre><p>Expand a quantum operator into a list of individual operators and their corresponding coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>h</code>: The quantum operator to be expanded.</li></ul><p><strong>Returns</strong></p><ul><li><code>ops</code>: A list of individual operators.</li><li><code>facs</code>: A list of corresponding coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/ordering.jl#L59-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumGraining.group_operators" href="#QuantumGraining.group_operators"><code>QuantumGraining.group_operators</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">group_operators(hs, gs, ωs; as_dict=true)</code></pre><p>Group operators based on their values and return the grouped operators.</p><p><strong>Arguments</strong></p><ul><li><code>hs</code>: An array of operators.</li><li><code>gs</code>: An array of coefficients corresponding to the operators.</li><li><code>ωs</code>: An array of corresponding elements.</li><li><code>as_dict</code>: A boolean indicating whether to return the grouped operators as dictionaries. Default is <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>as_dict</code> is <code>true</code>, returns two dictionaries <code>gs_dict</code> and <code>ωs_dict</code> where the keys are the operators and the values are the grouped coefficients and elements respectively.</li><li>If <code>as_dict</code> is <code>false</code>, returns three arrays <code>new_hs</code>, <code>new_gs</code>, and <code>new_ωs</code> where <code>new_hs</code> contains the grouped operators, <code>new_gs</code> contains the grouped coefficients, and <code>new_ωs</code> contains the grouped elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/ordering.jl#L89-L104">source</a></section><section><div><pre><code class="nohighlight hljs">group_operators(hs)</code></pre><p>Group operators in the given array <code>hs</code> by removing duplicates.</p><p><strong>Arguments</strong></p><ul><li><code>hs</code>: An array of operators.</li></ul><p><strong>Returns</strong></p><ul><li><code>new_hs</code>: An array of operators with duplicates removed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/leonbello/QuantumGraining.jl/blob/85833b295a1690ace8b424040464612910ecd985/src/ordering.jl#L135-L146">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« -</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/leonbello/QuantumGraining.jl"><strong>Back to GitHub</strong></a></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 23 May 2024 20:30">Thursday 23 May 2024</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
